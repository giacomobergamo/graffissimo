<!doctype html>
<html>
	<head>
		<title>Graffissimo</title>
		<style>
			body{ background-color: gray; }
			canvas{ background-color:white; }
		</style>
		<script id="shader-vs" type="x-shader/x-vertex">
                 attribute vec3 aVertexPosition;
                 void main(void) {
                 	gl_Position = vec4(aVertexPosition, 1.0);
                 	gl_PointSize = 5.0;
                 } 
		</script>
        <script id="shader-fs" type="x-shader/x-fragment">
                 void main(void) {
                 	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                 } 
		</script>
		<script>

			var gl = null, 
				canvas = null, 
				glProgram = null, 
				fragmentShader = null, 
				vertexShader = null;

			var mouseX, mouseY, mouseXPrev, mouseYPrev;

			var painting = false;
			var firstPaint = true;

        	var vertexPositionAttribute = null, 
        		lineVerticesBuffer = null;


      		function getMousePos(canvas, evt) {
        		var rect = canvas.getBoundingClientRect();
        		return {

        			// Convert coordinates to be between -1 and 1 for GL
          			x: (((evt.clientX - rect.left)/rect.width) *2) - 1,
          			y: ((((evt.clientY - rect.top)/rect.height) *2) - 1) * -1
       			};
      		}

			function initializeWebGL()
			{
				canvas = document.getElementById("my-canvas");

				canvas.addEventListener('mousemove', function(evt) {

					if (painting)
					{
        				var mousePos = getMousePos(canvas, evt);
        				//var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
        				//alert(message);
        				mouseXPrev = mouseX;
        				mouseYPrev = mouseY;
        				mouseX = mousePos.x;
        				mouseY = mousePos.y;

        				// If user just started drawing again (holding down the mouse button) we 
        				// don't want to create a line with the previous mouse position, so set previous 
        				// equal to current

        				if (firstPaint)
        				{
        					mouseXPrev = mouseX;
        					mouseYPrev = mouseY;
        					firstPaint = false;
        				}

        				setupLineBuffer(mouseXPrev, mouseYPrev, mouseX, mouseY);
						drawScene();
					}
      			}, false);

      			canvas.addEventListener('mousedown', function(evt) {
        			painting = true;
        			firstPaint = true;

      			}, false);

      			canvas.addEventListener('mouseup', function(evt) {
        			painting = false;

      			}, false);

				try {
					// Important to set the preserveDrawingBuffer flag to true when getting the context, otherwise 
					// buffer cleared each time you draw
					// http://asalga.wordpress.com/2011/08/01/using-webgl-readpixels-turn-on-preservedrawingbuffer/
					gl = canvas.getContext("webgl", {preserveDrawingBuffer: true});

				} catch(e) {

				}

				if (gl)
				{
					setupWebGL();
					initializeShaders();

				} else {
					alert("ERROR: Browser does not appear to support WebGL.");
				}
			}

			function setupWebGL()
			{
				// Set the clear color to black -- this is what we see before the shaders are compiled
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.clear(gl.COLOR_BUFFER_BIT);

			}

			function initializeShaders()
			{
				// Access the scripts above for the shader sources
				var fs_source = document.getElementById('shader-fs').innerHTML,
                  	vs_source = document.getElementById('shader-vs').innerHTML;

                // Compile shaders
        		vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
        		fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);

        		// Create program
        		glProgram = gl.createProgram();

        		// Attach and link shaders to the program
        		gl.attachShader(glProgram, vertexShader);
        		gl.attachShader(glProgram, fragmentShader);
        		gl.linkProgram(glProgram);
        		if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                	alert("ERROR: Unable to initialize the shader program.");
				}

        		// Use program
        		gl.useProgram(glProgram);

			}

			function makeShader(src, type)
			{

				// Compile the vertex shader
				var shader = gl.createShader(type);
				gl.shaderSource(shader, src);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
       				alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
				}
				return shader;
			}

			function setupLineBuffer(x1,y1,x2,y2)
			{

				var lineVertices = [x1,y1,0.0,x2,y2,0.0];
				lineVerticesBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, lineVerticesBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineVertices), gl.STATIC_DRAW);


			}

			function drawScene()
			{
				vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
				gl.enableVertexAttribArray(vertexPositionAttribute);
				gl.bindBuffer(gl.ARRAY_BUFFER, lineVerticesBuffer);
				gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
				gl.drawArrays(gl.LINES, 0, 2);
				//gl.drawArrays(gl.POINTS, 0, 2);

			}
		</script>
	</head>
	<body onload="initializeWebGL()">
		<div align="center"> 
			<canvas id="my-canvas" width="800" height="600">
				Your browser does not support the HTML5 canvas element.
			</canvas>
		</div>
	</body>
</html>